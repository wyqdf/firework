<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‚¹å‡»ç”ŸæˆçƒŸèŠ±</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            cursor: crosshair;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
        }

        .instruction {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 100;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        .instruction:hover {
            opacity: 1;
        }
    </style>
</head>

<body>
    <div class="instruction">ç‚¹å‡»ä»»æ„ä½ç½®æ”¾çƒŸèŠ± ğŸ†</div>
    <canvas id="canvas"></canvas>

    <script>

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // è®¾ç½®ç”»å¸ƒå°ºå¯¸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // å…¨å±€é¡µé¢å¯è§æ€§æ ‡è®°
        let isPageVisible = true;
        document.addEventListener('visibilitychange', () => { isPageVisible = !document.hidden; });


        function getTextPixels(text, fontSize = 100, fontFamily = 'Verdana', step = 6) {
            const offCanvas = document.createElement('canvas');
            const ctx = offCanvas.getContext('2d');

            offCanvas.width = fontSize * text.length;
            offCanvas.height = fontSize * 1.2;
            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#fff';
            ctx.fillText(text, 0, 0);

            const imageData = ctx.getImageData(0, 0, offCanvas.width, offCanvas.height);
            const data = imageData.data;
            const pixels = [];

            for (let y = 0; y < offCanvas.height; y += step) {  // æ¯ step è¡Œ
                for (let x = 0; x < offCanvas.width; x += step) {  // æ¯ step åˆ—
                    const index = (y * offCanvas.width + x) * 4;
                    const alpha = data[index + 3];
                    if (alpha > 128) {
                        pixels.push({ x, y });
                    }
                }
            }

            return pixels;
        }

        // çƒŸèŠ±ç²’å­ç±»
        class Particle {
            constructor(x, y, vx, vy, color, life = 120) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.gravity = 0.02 * Math.random() + 0.02;
                this.friction = 0.98;
                this.size = Math.random() * 2 + 1;
                this.update_count = 0;
            }

            update() {
                if (self.update_count++ % 3 === 0) { // æ¯ä¸¤å¸§æ›´æ–°ä¸€æ¬¡ä½ç½®
                    return;
                }
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.life--;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // æ·»åŠ å‘å…‰æ•ˆæœ
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        class Particle_Of_Words {
            constructor(x, y, vx, vy, color, life = 120) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.gravity = 0.1;
                this.friction = 0.98;
                this.size = Math.random() * 0.5 + 2.5;
                this.update_count = 0;
                this.total_lif = life;
            }

            update() {
                this.life--;
                if (this.update_count++ < this.total_lif * 0.99) { // æ¯ä¸¤å¸§æ›´æ–°ä¸€æ¬¡ä½ç½®
                    return;
                }
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;

            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // æ·»åŠ å‘å…‰æ•ˆæœ
                if (this.update_count++ > this.total_lif * 0.9) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.color;
                    ctx.fill();
                    ctx.restore();
                }

            }

            isDead() {
                return this.life <= 0;
            }
        }

        // çƒŸèŠ±ç±»
        class Firework {
            constructor(x, y) {
                this.startX = x;
                this.startY = y;
                this.x = x;
                this.y = canvas.height; // ä»åº•éƒ¨å‡ç©º
                this.targetY = y;       // å‡ç©ºç›®æ ‡é«˜åº¦
                this.particles = [];
                this.colors = [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7',
                    '#dda0dd', '#ff9ff3', '#54a0ff', '#5f27cd', '#ff3838',
                    '#00d2d3', '#ff9ff3', '#ffa726', '#42a5f5', '#ab47bc'
                ];
                this.exploded = false;
                this.rocketSpeed = 2 + Math.random() * 3;
                this.trail = []; // ç«ç®­å°¾è¿¹
                this.trailMaxLength = 5; // å°¾è¿¹é•¿åº¦
            }

            createParticles() {
                const particleCount = Math.random() * 60 + 30;
                const color = this.colors[Math.floor(Math.random() * this.colors.length)];

                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const velocity = Math.random() * 4 + 1;
                    const vx = Math.cos(angle) * velocity;
                    const vy = Math.sin(angle) * velocity;

                    const particleColor = Math.random() > 0.7 ?
                        this.colors[Math.floor(Math.random() * this.colors.length)] : color;

                    this.particles.push(new Particle(
                        this.x, this.y, vx, vy, particleColor,
                        Math.random() * 40 + 80
                    ));
                }
            }

            update() {
                if (!this.exploded) {
                    // ä¿å­˜å°¾è¿¹
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > this.trailMaxLength) this.trail.shift();

                    // å‡ç©º
                    this.y -= this.rocketSpeed;
                    if (this.y <= this.targetY) {
                        this.exploded = true;
                        this.createParticles();
                    }
                } else {
                    // æ›´æ–°ç²’å­
                    this.particles = this.particles.filter(p => {
                        p.update();
                        return !p.isDead();
                    });
                }
            }

            draw() {
                if (!this.exploded) {
                    // ç»˜åˆ¶æ¸å˜å°¾ç„°
                    ctx.save();
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const p0 = this.trail[i];
                        const p1 = this.trail[i + 1];
                        const grad = ctx.createLinearGradient(p0.x, p0.y, p1.x, p1.y);
                        grad.addColorStop(0, 'rgba(255,255,255,0.8)');
                        grad.addColorStop(1, 'rgba(255,165,0,0)'); // æ©™è‰²æ¸éš
                        ctx.strokeStyle = grad;
                        ctx.lineWidth = (i / this.trail.length) * 3 + 1; // å°¾ç„°éšé•¿åº¦å˜ç»†
                        ctx.beginPath();
                        ctx.moveTo(p0.x, p0.y);
                        ctx.lineTo(p1.x, p1.y);
                        ctx.stroke();
                    }
                    ctx.restore();

                    // ç»˜åˆ¶ç«ç®­
                    ctx.save();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else {
                    // ç»˜åˆ¶ç²’å­
                    this.particles.forEach(p => p.draw());
                }
            }

            isDead() {
                return this.exploded && this.particles.length === 0;
            }
        }

        class Words_Firework {
            constructor(x, y) {
                this.startX = x;
                this.startY = y;
                this.x = x;
                this.y = canvas.height; // ä»åº•éƒ¨å‡ç©º
                this.targetY = y;       // å‡ç©ºç›®æ ‡é«˜åº¦
                this.particles = [];
                this.exploded = false;
                this.rocketSpeed = 3 + Math.random() * 3;
                this.trail = []; // ç«ç®­å°¾è¿¹
                this.trailMaxLength = 3; // å°¾è¿¹é•¿åº¦
                this.words = [
                    "æ–°å¹´å¿«ä¹", "ä¸‡äº‹å¦‚æ„", "å¿ƒæƒ³äº‹æˆ", "å²å²å¹³å®‰", "ç¦æ˜Ÿé«˜ç…§",
                    "å‰ç¥¥å¦‚æ„", "æ­¥æ­¥é«˜å‡", "è´¢æºå¹¿è¿›", "é¾™é©¬ç²¾ç¥", "é¹ç¨‹ä¸‡é‡Œ",
                    "èŠ±å¼€å¯Œè´µ", "å››å­£å¹³å®‰", "åˆå®¶æ¬¢ä¹", "äº‹ä¸šæœ‰æˆ", "å¹¸ç¦ç¾æ»¡",
                    "æ‹›è´¢è¿›å®", "å¤§å±•å®å›¾", "é‡‘ç‰æ»¡å ‚", "ç¦å¦‚ä¸œæµ·", "å¯¿æ¯”å—å±±", "å‰æ˜Ÿé«˜ç…§",
                    "ç¦å¯¿å®‰åº·", "å¿ƒæƒ³äº‹æˆ", "é¾™è…¾è™è·ƒ", "é¹ç¨‹ä¸‡é‡Œ", "å‰ç¨‹ä¼¼é”¦", "ä¸€å¸†é£é¡º", "ä¸‡äº‹èƒœæ„",
                    "ç¦æ»¡äººé—´", "å–œæ°”æ´‹æ´‹", "é˜–å®¶å¹¸ç¦", "è´¢æºæ»šæ»š", "æ­¥æ­¥é«˜å‡", "å‰ç¥¥å®‰åº·", "ç¦æ˜Ÿé«˜ç…§", "é¾™å‡¤å‘ˆç¥¥", "å››å­£å‘è´¢", "èŠ±å¼€å¯Œè´µ", "é‡‘ç‰æ»¡å ‚", "ç¦å¦‚ä¸œæµ·"
                ];
            }

            createParticles() {
                let size = Math.random() * 80 + 50;
                let text = this.words[Math.floor(Math.random() * this.words.length)];
                let pixels = getTextPixels(text, size);

                // éšæœºåŸºè‰²
                const baseHue = Math.random() * 360; // 0~360Â° ä»»æ„é¢œè‰²
                const minLight = 40; // æœ€æš—äº®åº¦
                const maxLight = 80; // æœ€äº®äº®åº¦
                const minSat = 50;   // æœ€ä½é¥±å’Œåº¦
                const maxSat = 100;  // æœ€é«˜é¥±å’Œåº¦

                const minX = pixels[0].x;
                const maxX = pixels[pixels.length - 1].x;

                for (let i = 0; i < pixels.length; i++) {
                    const pixel = pixels[i];

                    // æ ¹æ®xåæ ‡ç”Ÿæˆäº®åº¦æ¸å˜
                    const t = (pixel.x - minX) / (maxX - minX); // 0~1
                    const light = minLight + (maxLight - minLight) * t;
                    const sat = minSat + (maxSat - minSat) * t;
                    const color = `hsl(${baseHue}, ${sat}%, ${light}%)`;

                    const angle = (Math.PI * 2 * i) / pixels.length;
                    const velocity = Math.random() * 2 + 1;
                    const vx = Math.cos(angle) * velocity;
                    const vy = Math.sin(angle) * velocity;

                    const x = pixel.x + this.x - (pixels[pixels.length - 1].x - pixels[0].x) / 2;
                    const y = pixel.y + this.y - 40;

                    this.particles.push(new Particle_Of_Words(
                        x, y, vx, vy, color,
                        Math.random() * 40 + 80
                    ));
                }
            }


            update() {
                if (!this.exploded) {
                    // ä¿å­˜å°¾è¿¹
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > this.trailMaxLength) this.trail.shift();

                    // å‡ç©º
                    this.y -= this.rocketSpeed;
                    if (this.y <= this.targetY) {
                        this.exploded = true;
                        this.createParticles();
                    }
                } else {
                    // æ›´æ–°ç²’å­
                    this.particles = this.particles.filter(p => {
                        p.update();
                        return !p.isDead();
                    });
                }
            }

            draw() {
                if (!this.exploded) {
                    // ç»˜åˆ¶æ¸å˜å°¾ç„°
                    ctx.save();
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const p0 = this.trail[i];
                        const p1 = this.trail[i + 1];
                        const grad = ctx.createLinearGradient(p0.x, p0.y, p1.x, p1.y);
                        grad.addColorStop(0, 'rgba(255,255,255,0.8)');
                        grad.addColorStop(1, 'rgba(255,165,0,0)'); // æ©™è‰²æ¸éš
                        ctx.strokeStyle = grad;
                        ctx.lineWidth = (i / this.trail.length) * 3 + 1; // å°¾ç„°éšé•¿åº¦å˜ç»†
                        ctx.beginPath();
                        ctx.moveTo(p0.x, p0.y);
                        ctx.lineTo(p1.x, p1.y);
                        ctx.stroke();
                    }
                    ctx.restore();

                    // ç»˜åˆ¶ç«ç®­
                    ctx.save();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else {
                    // ç»˜åˆ¶ç²’å­
                    this.particles.forEach(p => p.draw());
                }
            }

            isDead() {
                return this.exploded && this.particles.length === 0;
            }
        }

        // ç®¡ç†æ‰€æœ‰çƒŸèŠ±
        fireworks = [];
        function animate() {

            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            fireworks = fireworks.filter(firework => {
                firework.update();
                firework.draw();
                return !firework.isDead();
            });
            requestAnimationFrame(animate);
        }
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // åˆ›å»ºæ–°çƒŸèŠ±
            if (fireworks.length < 8) fireworks.push(new Words_Firework(x, y));
            // éšè—æŒ‡ç¤ºæ–‡å­—
            document.querySelector('.instruction').style.opacity = '0.3';
            setTimeout(() => {
                document.querySelector('.instruction').style.opacity = '0.8';
            }, 2000);
        });

        // è§¦æ‘¸äº‹ä»¶æ”¯æŒï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            if (fireworks.length < 8) {
                fireworks.push(new Firework(x, y));
            }
        });

        // è‡ªåŠ¨çƒŸèŠ±æ¼”ç¤ºï¼ˆå¯é€‰ï¼‰
        function autoFirework() {
            if (fireworks.length > 4)
                return;
            if (Math.random() < 0.3) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height * 0.7 + canvas.height * 0.1;
                fireworks.push(new Firework(x, y));
            }
            else if (Math.random() < 0.04) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height * 0.6 + canvas.height * 0.2;
                fireworks.push(new Words_Firework(x, y));
            }
        }

        // å¯åŠ¨åŠ¨ç”»
        animate();

        // æ¯éš”ä¸€æ®µæ—¶é—´è‡ªåŠ¨æ”¾çƒŸèŠ±ï¼ˆå¯é€‰ï¼‰
        setInterval(() => { if (isPageVisible) autoFirework(); }, 200);

        // é”®ç›˜å¿«æ·é”®ï¼ˆç©ºæ ¼é”®æ”¾çƒŸèŠ±ï¼‰
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if (fireworks.length > 10)
                    return;
                e.preventDefault();
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height * 0.6 + canvas.height * 0.2;
                fireworks.push(new Firework(x, y));
            }
        });
    </script>
</body>

</html>
